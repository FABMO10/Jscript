<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Simple Shooter – Zig‑Zag Target</title>
  <style>
    :root {
      --bg: #0b1020;
      --panel: #111934;
      --accent: #5be49b;
      --accent-2: #58a6ff;
      --text: #e6f1ff;
      --muted: #8aa0c2;
    }
    html, body {
      margin: 0; height: 100%; background: var(--bg); color: var(--text);
      font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      overflow: hidden;
    }
    .hud {
      position: fixed; inset: 0; pointer-events: none;
    }
    .score {
      position: absolute; top: 12px; right: 16px; 
      background: color-mix(in hsl, var(--panel) 85%, transparent);
      border: 1px solid #223056; border-radius: 10px;
      padding: 8px 12px; font-weight: 700; letter-spacing: .5px;
      text-shadow: 0 1px 0 rgba(0,0,0,.3);
    }
    .help {
      position: absolute; left: 16px; top: 12px; max-width: 40ch;
      color: var(--muted); font-size: 14px; line-height: 1.2;
      background: color-mix(in hsl, var(--panel) 85%, transparent);
      border: 1px solid #223056; border-radius: 10px; padding: 8px 12px;
    }
    .footer {
      position: absolute; left: 50%; bottom: 10px; transform: translateX(-50%);
      font-size: 12px; color: var(--muted);
      background: color-mix(in hsl, var(--panel) 85%, transparent);
      border: 1px solid #223056; border-radius: 10px; padding: 6px 10px;
    }
    canvas { display:block; width:100vw; height:100vh; }
  </style>
</head>
<body>
  <canvas id="game" aria-label="Shooting range"></canvas>
  <div class="hud" aria-hidden>
    <div class="help">
      <div><strong>How to play</strong></div>
      <div>Move the mouse/trackpad to aim the cannon at the bottom.</div>
      <div><strong>Right‑click</strong> to shoot. Hit the moving target to score.</div>
      <div>Press <kbd>R</kbd> to reset score.</div>
    </div>
    <div class="score" id="score">Score: 0</div>
    <div class="footer">Tip: If your browser shows a context menu on right‑click, the game will suppress it on the canvas.</div>
  </div>

  <script>
  (() => {
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // Logical canvas size (we scale to full window each frame)
    function resize() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      canvas.width = Math.floor(innerWidth * dpr);
      canvas.height = Math.floor(innerHeight * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
    }
    addEventListener('resize', resize, { passive: true });
    resize();

    // Game state
    let score = 0;
    const scoreEl = document.getElementById('score');

    const gun = {
      baseY() { return canvas.height / (window.devicePixelRatio || 1) - 40; },
      x() { return canvas.width / (window.devicePixelRatio || 1) / 2; },
      angle: -Math.PI / 2, // straight up
      length: 80,
    };

    const target = {
      x: 120, y: 120, r: 24,
      vx: 180, // px/s horizontally
      stepY: 60, // how far to drop when bouncing – makes a zigzag path
      dir: 1,
      lastDrop: 0,
    };

    const crosshair = { x: innerWidth/2, y: innerHeight/2 };

    // Input: track mouse to aim
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      crosshair.x = e.clientX - rect.left;
      crosshair.y = e.clientY - rect.top;
      const dx = crosshair.x - gun.x();
      const dy = crosshair.y - gun.baseY();
      gun.angle = Math.atan2(dy, dx);
    });

    // Prevent the default context menu & shoot with right button
    canvas.addEventListener('contextmenu', (e) => e.preventDefault());
    canvas.addEventListener('mousedown', (e) => {
      if (e.button === 2) { // right click
        shoot();
      }
    });

    addEventListener('keydown', (e) => {
      if (e.key.toLowerCase() === 'r') reset();
    });

    function reset() {
      score = 0; scoreEl.textContent = `Score: ${score}`;
      target.x = 120; target.y = 120; target.vx = 180; target.dir = 1; target.lastDrop = 0;
    }

    function shoot() {
      // Simple hit test: if the crosshair is inside the target when you shoot
      const dx = crosshair.x - target.x;
      const dy = crosshair.y - target.y;
      if (Math.hypot(dx, dy) <= target.r) {
        score++;
        scoreEl.textContent = `Score: ${score}`;
        // Give feedback and nudge target speed a bit
        flash(140);
        target.vx *= 1.05; // gets a tad harder
        // Reposition target to a fresh lane
        target.y = clamp(80, innerHeight - 180, target.y + (Math.random() < .5 ? -1 : 1) * (target.stepY * 1.5));
      } else {
        flash(60);
      }
    }

    // Small white flash for feedback
    let flashAlpha = 0;
    function flash(intensity=120) { flashAlpha = Math.min(200, flashAlpha + intensity); }

    // Helpers
    function clamp(min, max, v) { return Math.max(min, Math.min(max, v)); }

    // Main loop
    let last = performance.now();
    function loop(now) {
      const dt = Math.min(0.033, (now - last) / 1000); // cap to avoid jumps
      last = now;

      update(dt);
      render();
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    function update(dt) {
      // Move target horizontally
      target.x += target.vx * dt * target.dir;
      const W = innerWidth, H = innerHeight;
      const margin = 24;
      // Bounce at edges, drop down (zigzag)
      if (target.x < margin + target.r) {
        target.x = margin + target.r; target.dir = 1; target.y += target.stepY; 
      }
      if (target.x > W - margin - target.r) {
        target.x = W - margin - target.r; target.dir = -1; target.y += target.stepY;
      }
      // Keep target inside vertical bounds
      if (target.y > H - 180 || target.y < 80) {
        target.y = clamp(80, H - 180, target.y);
      }

      // Fade flash
      if (flashAlpha > 0) flashAlpha = Math.max(0, flashAlpha - 400 * dt);
    }

    function render() {
      const W = innerWidth, H = innerHeight;
      ctx.clearRect(0, 0, W, H);

      // Background "design" grid
      drawBackground(W, H);

      // Draw target
      drawTarget(target.x, target.y, target.r);

      // Draw gun at bottom center
      drawGun();

      // Draw aim line & crosshair
      drawAim();

      // Flash overlay
      if (flashAlpha > 0) {
        ctx.save(); ctx.globalAlpha = flashAlpha / 255; ctx.fillStyle = '#ffffff';
        ctx.fillRect(0,0,W,H); ctx.restore();
      }
    }

    function drawBackground(W, H) {
      ctx.save();
      ctx.fillStyle = '#0d1430';
      ctx.fillRect(0,0,W,H);
      // subtle grid
      ctx.strokeStyle = 'rgba(140,170,255,0.08)';
      ctx.lineWidth = 1;
      for (let x = 0; x < W; x += 40) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
      for (let y = 0; y < H; y += 40) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
      // highlight playable strip near bottom
      ctx.fillStyle = 'rgba(88,166,255,0.06)';
      ctx.fillRect(0, H-160, W, 160);
      ctx.restore();
    }

    function drawTarget(x, y, r) {
      ctx.save();
      // halo
      const grd = ctx.createRadialGradient(x, y, 2, x, y, r*2);
      grd.addColorStop(0, 'rgba(91,228,155,0.35)');
      grd.addColorStop(1, 'rgba(91,228,155,0)');
      ctx.fillStyle = grd; ctx.beginPath(); ctx.arc(x, y, r*2.2, 0, Math.PI*2); ctx.fill();
      // main disc
      ctx.beginPath(); ctx.fillStyle = '#5be49b'; ctx.strokeStyle = '#1a3b2b'; ctx.lineWidth = 3;
      ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill(); ctx.stroke();
      // bullseye
      ctx.beginPath(); ctx.fillStyle = '#103a24'; ctx.arc(x, y, r*0.35, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }

    function drawGun() {
      const baseX = gun.x();
      const baseY = gun.baseY();
      ctx.save();
      // base
      ctx.fillStyle = '#1b2442';
      ctx.strokeStyle = '#223056';
      ctx.lineWidth = 2;
      ctx.beginPath();
      const w = 120, h = 30, r = 12;
      // rounded rectangle for base
      roundRect(ctx, baseX - w/2, baseY + 12, w, h, r);
      ctx.fill(); ctx.stroke();

      // barrel
      ctx.translate(baseX, baseY);
      ctx.rotate(gun.angle);
      ctx.fillStyle = '#58a6ff';
      ctx.strokeStyle = '#1b355b';
      ctx.beginPath();
      ctx.moveTo(0, -8);
      ctx.lineTo(gun.length, -4);
      ctx.lineTo(gun.length, 4);
      ctx.lineTo(0, 8);
      ctx.closePath();
      ctx.fill(); ctx.stroke();

      // muzzle glow
      ctx.beginPath();
      ctx.fillStyle = 'rgba(88,166,255,0.25)';
      ctx.arc(gun.length, 0, 14, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }

    function drawAim() {
      const baseX = gun.x();
      const baseY = gun.baseY();
      const mx = crosshair.x, my = crosshair.y;
      // aim line
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.25)';
      ctx.setLineDash([6, 10]);
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(baseX, baseY); ctx.lineTo(mx, my); ctx.stroke();
      ctx.restore();

      // crosshair
      ctx.save();
      ctx.translate(mx, my);
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(255,255,255,0.8)';
      ctx.beginPath(); ctx.arc(0, 0, 14, 0, Math.PI * 2); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(-20,0); ctx.lineTo(20,0); ctx.moveTo(0,-20); ctx.lineTo(0,20); ctx.stroke();
      ctx.restore();
    }

    function roundRect(ctx, x, y, w, h, r) {
      const rr = Math.min(r, w/2, h/2);
      ctx.moveTo(x + rr, y);
      ctx.lineTo(x + w - rr, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + rr);
      ctx.lineTo(x + w, y + h - rr);
      ctx.quadraticCurveTo(x + w, y + h, x + w - rr, y + h);
      ctx.lineTo(x + rr, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - rr);
      ctx.lineTo(x, y + rr);
      ctx.quadraticCurveTo(x, y, x + rr, y);
    }
  })();
  </script>
</body>
</html>
